const {Vec3} = require('vec3')
const {RaycastIterator} = require('prismarine-world').iterators

module.exports = (bot) => {
    function trueDistance(playerEntity) {
        const {x, y, z} = bot.entity.position.offset(0, bot.entity.height, 0)
        const aabb = bot.getEntityAABB({
            position: playerEntity.position,
            height: 1.8,
            width: 0.3
        });
        let dx = Math.max(aabb.minX - x, 0, x - aabb.maxX);
        let dy = Math.max(aabb.minY - y, 0, y - aabb.maxY);
        let dz = Math.max(aabb.minZ - z, 0, z - aabb.maxZ);
        return Math.sqrt(dx * dx + dy * dy + dz * dz);
    }

    function getViewDirection(pitch, yaw) {
        const csPitch = Math.cos(pitch)
        const snPitch = Math.sin(pitch)
        const csYaw = Math.cos(yaw)
        const snYaw = Math.sin(yaw)
        return new Vec3(-snYaw * csPitch, snPitch, -csYaw * csPitch)
    }

    bot.blockInSight = (maxSteps = 256, vectorLength = 5 / 16) => {
        console.warn('[deprecated] use bot.blockAtCursor instead')
        const block = bot.blockAtCursor(maxSteps * vectorLength)
        if (block) return block
    }

    bot.blockAtCursor = (maxDistance = 256, matcher = null) => {
        const {position, height, pitch, yaw} = bot.entity

        const eyePosition = position.offset(0, height, 0)
        const viewDirection = getViewDirection(pitch, yaw)

        return bot.world.raycast(eyePosition, viewDirection, maxDistance, matcher)
    }

    bot.entityAtCursor = (maxDistance = 3.5) => {
        const lastSentPos = bot.entity.position
        const block = bot.blockAtCursor(maxDistance)
        maxDistance = block?.intersect.distanceTo(lastSentPos) ?? maxDistance

        const entities = Object.values(bot.entities)
            .filter(entity => entity.type === 'player' && entity.username !== bot.username && trueDistance(entity) <= maxDistance)

        const dir = new Vec3(-Math.sin(bot.entity.yaw) * Math.cos(bot.entity.pitch), Math.sin(bot.entity.pitch), -Math.cos(bot.entity.yaw) * Math.cos(bot.entity.pitch))
        const iterator = new RaycastIterator(lastSentPos.offset(0, bot.entity.height, 0), dir.normalize(), maxDistance)

        let targetEntity = null
        let targetDist = maxDistance

        for (let i = 0; i < entities.length; i++) {
            const entity = entities[i]
            const w = entity.width / 2

            const shapes = [[-w, 0, -w, w, entity.height + (entity.type === 'player' ? 0.18 : 0), w]]
            const intersect = iterator.intersect(shapes, entity.position)
            if (intersect) {
                const entityDir = entity.position.minus(lastSentPos) // Can be combined into 1 line
                const sign = Math.sign(entityDir.dot(dir))
                if (sign !== -1) {
                    const dist = trueDistance(entity)
                    if (targetDist >= dist) {
                        targetEntity = entity
                        targetDist = dist
                    }
                }
            }
        }

        return targetEntity
    }

    bot.blockAtEntityCursor = (entity = bot.entity, maxDistance = 256, matcher = null) => {
        if (!entity.position || !entity.height || !entity.pitch || !entity.yaw) return null
        const {position, height, pitch, yaw} = entity

        const eyePosition = position.offset(0, height, 0)
        const viewDirection = getViewDirection(pitch, yaw)

        return bot.world.raycast(eyePosition, viewDirection, maxDistance, matcher)
    }
}
